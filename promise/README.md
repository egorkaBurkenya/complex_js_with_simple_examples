# circuit

## Замыкания 

На самом деле, **замыкания**, это очень простой концепт, если не объяснять его сложными словами 

> Что же такое замыкания ?  
> Замыкание - это функция внутри другой функции ... и все ! 

Давайте разберемся, как же это работает:

Создадим новую функцию `createMultFn`, которая будет возвращать новую функцию и для примера она будет выводить в консоль `1000 * n`, а параметр `n` мы будем передавать в нашу функцию `createMultFn`:

```javascript
function createMultFn(n) {
  return function() {
    console.log(1000 * n);
  }
}
```

Давайте воспользуемся нашей новой функцией:

```javascript 
const mult = createMultFn(5)
mult()
____________________________
<- 5000
```
Так как функция `createMultFn` возвращает нам новую функцию, мы записываем результат ее выполнения, передав в качестве параметра `5` и далее вызываем ново созданную функцию и получаем результат `5000`, хотя мы не передавали никаких параметров в функцию `mult()`

Вот как это работает: *когда мы вызывали функцию `createMultFn` и передавали в нее число `5` она отработала и вернула нам новую функцию, но учитывая, что новая функция была вызвана в контексте `createMultFn` переменная `n`, была "замкнута" в той функции, которую мы возвращаем. И поэтому, теперь всегда, когда мы вызываем функцию `mult()` в ней уже хранится значение `n` - "функция ее замкнула"* И именно поэтому, это и называется **"Замыканием"**
***
### Давайте разберем на контретных примерах, как это может быть нам полезно и как это работает!

Создадим новую функцию `urlGenerator`:
```javascript
function urlGenerator(domain) {
  return function(url){
    return `https://${url}.${domain}`
  }
}
```
Функция будет возвращать нам функцию, которая в свою очередь будет возвращать сгенерированную ссылку исходя из параметра `url`, который мы должны передавать в функцию, но так же для создания рабочей ссылки, нам нужен доменный адрес, который не особо хочется, каждый раз вводить в ручную. Поэтому мы будем передавать `domain` в фунцию `urlGenerator` что бы создать замыкание  
Давайте посмотрим и разберем, как это работает:

```javascript
const comUrl = urlGenerator('com') // создадим новую функцию, для генирации ссылок с доменном "com"
const ruUrl = urlGenerator('ru') // и такую же для генирации ссылок с доменном "ru"

// попробуем использовать функции и посмотрим на результат:

console.log(comUrl('google')); 
console.log(comUrl('gmail'));

console.log(ruUrl('yandex'));
console.log(ruUrl('mail'));
_______________________________
"https://google.com" 
"https://gmail.com"
"https://yandex.ru" 
"https://mail.ru"
```

Мы получаем ожидаемый результат, потому что замкнули значение `domain` в функциях `comUrl` и `ruUrl`, таким образом мы получили уневерсальные функции для генирации ссылок, в которые нам не требуется каждый раз передавать доменный адрес !   

# Практическая задача
## Условие:
задача создать новую функцию `bind`, которая должна принимать в себя (перывм параметром) некоторый контекст и далее "биндит" этот контекст к функции(второй параметр)
```javascript
/*
  Написать новую функцию bind 
  Пример работы:

  function logSomeone() {
    console.log(`Person: ${this.name}, ${this.age}, ${this.job}`)
  }

  const personOne = {name: 'Egor', age: 17, job: 'Frontend'}
  const personTwo = {name: 'Oleg', age: 25, job: 'PhotoShop'}

  bind(personOne, logSomeone)
  bind(personTwo, logSomeone)
*/
```
## Решение:
```javascript
function bind(context, fn) { // создаем новую функцию bind, куда мы будем передавать котекст и функцию
  return function(...args) { // возвращаем новую функцию, в которую мы должны передавать аргументы
    fn.apply(context, args)
}

function logSomeone() {
  console.log(`Person: ${this.name}, ${this.age}, ${this.job}`)
}

const personOne = {name: 'Egor', age: 17, job: 'Frontend'}
const personTwo = {name: 'Oleg', age: 25, job: 'PhotoShop'}

bind(personOne, logSomeone)()
bind(personTwo, logSomeone)()
_______________________________________________________________
Person: Egor, 17, Frontend 
Person: Oleg, 25, PhotoShop
```
Мы используем метод `apply` для того что бы наша функция была унивирсальной (см [prototype](https://github.com/egorkaBurkenya/complex_js_with_simple_examples/tree/this)) в который перывм параметром передаеться контекст, а вторым массив, с любым кол-во аргументов.
